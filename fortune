#!/usr/bin/env python2.6

import glob
import optparse
import random
import re
import sys
import textwrap
from collections import namedtuple
from os import path
from pprint import pprint

import yaml


Quote = namedtuple("Quote", ["text", "attribution", "ref", "tags"])


def main(args):
  optparser = optparse.OptionParser(usage="%prog [OPTION..] [QUOTE FILE..]")
  optparser.add_option("-w", "--width", type="int", default=79)
  optparser.add_option("--max-width", type="int", default=None, help="width = min(width, max_width)")
  optparser.add_option("-v", "--verbose", action="store_true", default=False)
  optparser.add_option("--debug", action="store_true", default=False)
  optparser.add_option("--grep", nargs=1, default=None)
  optparser.add_option("--no-wrap", dest="wrap", action="store_false", default=True)
  optparser.add_option("-1", "--oneline", action="store_true", default=False,
    help="(implies no-wrap)")
  optparser.add_option("-n", type="int", default=1,
    help="run N times")
  opts, args = optparser.parse_args(args)

  if opts.n < 1 or (opts.n > 1 and opts.grep):
    optparser.error("invalid N")

  if opts.max_width:
    opts.width = min(opts.width, opts.max_width)

  if opts.oneline:
    opts.wrap = False

  if args:
    filenames = args
  else:
    filenames = glob.glob("%s/quotes*.yaml" % path.dirname(__file__))

  if opts.debug or opts.verbose:
    print "opts:", repr(opts)
    print "args:", repr(args)
    print "filenames:", repr(filenames)
    if opts.debug:
      return

  quotes = []
  for filename in filenames:
    if filename.startswith("-"):
      return "unexpected option"
    collection = path.splitext(path.basename(filename))[0]
    for doc in yaml.load_all(open(filename)):
      q = doc.get("q")
      if "title" in doc:
        a = doc["title"]
      elif "by" in doc:
        a = doc["by"]
        source = doc.get("source")
        if source:
          a += ", " + source
      elif "source" in doc:
        a = doc["source"]
      else:
        a = None

      if "ref" in doc:
        ref = doc["ref"]
        if isinstance(ref, list):
          ref = ", ".join(ref)
      elif "when" in doc:
        ref = str(doc["when"])
      else:
        ref = None

      tags = doc.get("tags", "")

      q = Quote(q, a, ref, tags)
      quotes.append((collection, q))

  if opts.verbose:
    print "[loaded %d quotes from %d files]" % (len(quotes), len(filenames))

  def show_quote(q, collection):
    text = q.text.strip()
    if opts.wrap:
      text = textwrap.fill(text, width=opts.width)

    attr = q.attribution or "(unknown)"
    if q.ref:
      attr += "; " + q.ref

    end_text = "-- %s [%s]" % (attr, collection)

    sep = " " if opts.oneline else "\n  "
    print sep.join((text, end_text))

  if opts.grep:
    if re.escape(opts.grep) == opts.grep:  # not a regex, could be improved
      opts.grep = opts.grep.lower()
      def grep(s):
        return opts.grep in s.lower()
    else:
      grep = re.compile(opts.grep, re.I).search
    for collection, q in quotes:
      if any(grep(t) for t in q if t):
        show_quote(q, collection)
  else:
    for _ in xrange(opts.n):
      collection, q = random.choice(quotes)
      show_quote(q, collection)


if __name__ == "__main__":
  sys.exit(main(sys.argv[1:]))
